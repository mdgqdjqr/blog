---
title: 数据结构
date: 2022-03-07 09:56:16
tags:
  - 考研
  - 专业课
  - 数据结构
  - 算法
categories:
  - 学术知识积累
mathjax: true
---

该文为学习笔记，仅作学习参考，如有错误，望指正！

<!--more-->

#	第一章.	绪论

数据结构在学什么？

​		<font color=red>如何用程序代码把现实世界的问题信息化</font>。

##	1.	数据结构的基本概念

本章内容索引：

![](1.1.1.png)

**相关概念：**

数据：数据是<font color=red>信息的载体</font>，是描述客观事物属性的数、字符以及所有<font color=red>能输入到计算机中并被计算机程序识别</font>和处理的符号的集合。数据是计算机程序加工的原料。

数据元素、数据项：**数据元素**是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素是由若干个数据项组成的，**数据项**是构成数据元素的不可分割的最小单位。

数据对象：是具有<font color=red>相同性质</font>的数据元素的集合，是数据的一个子集。

数据结构：是相互之间存在一种或多种特定<font color=red>关系</font>的数据元素的集合。

数据类型：是一个值的集合和定义在此集合上的一组操作的总称。

1. 原子类型：其值不可再分的数据类型。
2. 结构类型：其值可以再分解为若干成分（分量）的数据类型。

抽象数据类型（Abstract Data Type，ADT）：是抽象数据组织及与之相关的操作。用数学化的语言定义数据的逻辑结构、定义运算，与具体的实现无关。

**数据的逻辑结构：**

集合：各个元素同属一个集合，别无其他关系；

线性结构：元素之间是一对一的关系，除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继；

树形结构：数据元素之间是一对多的关系；

图形结构：数据元素之间是多对多的关系；

**数据的物理结构（存储结构）：**

顺序存储：把<font color=red>逻辑上相邻的元素存储在物理位置上也相邻的存储单元中</font>，元素之间的关系由存储单元的邻接关系来体现。

链式存储：<font color=red>逻辑上相邻的元素在物理位置上可以不相邻</font>，借助指示元素存储位置的指针来表示元素之间的逻辑关系。

索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）

散列存储：根据元素的关键字直接计算出该元素的存储地址，又称<font color=red>哈希（Hash）存储</font>。

<font color=red>【小结】</font>：

1. 若采用<font color=red>顺序存储</font>，则各个数据元素之间在物理上必须是<font color=red>连续的</font>，若采用<font color=red>非顺序存储</font>，则各个数据元素在物理上可以是<font color=red>离散的</font>。
2. 数据的<font color=red>存储结构</font>会<font color=red>影响存储空间分配的方便程度</font>。

**数据的运算：**

施加在数据上的运算包括运算的定义和实现。

<font color=red>运算的定义</font>是<font color=red>针对逻辑结构</font>的。

<font color=red>运算的实现</font>是<font color=red>针对存储结构</font>的。

<font color=red>根据逻辑结构来定义，根据存储结构来实现</font>。



##	2.	算法的基本概念

**程序=数据结构+算法；**

1. 数据结构：是要处理的信息；
2. 算法：是处理信息的步骤；

**算法的特性：**

1. 有穷性：有穷时间内能执行完成。<font color=red>算法是有穷的，程序可以是无穷的</font>。
2. 确定性：<font color=red>相同的输入</font>只会产生<font color=red>相同的输出</font>。
3. 可行性：可以用已有的基本操作实现算法。
4. 输入：一个算法<font color=red>有 0 个或多个输入</font>，即丢给算法处理的数据。
5. 输出：一个算法<font color=red>有 1 个或多个输出</font>，即算法处理的结果。

**"好"算法的特质：**

1. 正确性：算法应能够正确地解决求解问题。

2. 可读性：算法应具有良好的可读性，以帮助人们理解。

   <font color=red>注意</font>：算法可以用伪代码描述，甚至用文字描述，重要的是要"无歧义"地描述出解决问题的步骤。

3. 健壮性：输入非法数据时，算法能适当地作出反应或进行处理，而不会产生莫名其妙的输出结果。

4. 高效率与低存储量需求：

   1. 高效率：执行速度快，时间复杂度低；
   2. 低存储量：不费内存，空间复杂度低；



##	3.	算法的时间复杂度

**算法的时间复杂度：**

```Python
void loveyou(int n){
    int i=1;
    while(i<=n){
        i++;
        printf("I Love You Than %d.\n", n);
    }
    printf("I Love You More than %d.\n", n);
}
int main(){
    loveyou(3000);
}
```





#	第二章	线性表

##	1.	线性表的定义

###	1.	定义

$n(n>=0)$ 个数据元素的有限序列，可表示为：$(a_1，a_2，a_3， ...， a_n)$

- $a_1 \sim a_n$ 是 n 个数据元素
- n 为线性表长度，$n=0$ 时为空表



###	2.	表示形式

可表示为：$(a_1，a_2，a_3，...， a_n)$

还可以表示为二元数组形式：(D，S)

- D 表示元素的集合：$D={(a_1，a_2，a_3，...， a_n)}$
- S 表示关系集合（前驱后继）：$S={(a_1，a_2)，(a_2，a_3)，...，(a_{n-1}，a_n)}$



###	3.	元素关系

对于非空线性表：$a_1，a_2，a_3， ...， a_{n-1}，a_n)$$

- 有且仅有一个开始结点 $a_1$，它没有前驱，而仅有一个后继 $a_2$
- 有且仅有一个终端结点 $a_n$，它没有后继，而仅有一个前驱 $a_{n-1}$
- 其余的内部结点 $a_i（2\leq i\leq n-1）都有且仅有一个前驱$$a_{i-1}$和一个后继 $a_{i+1}$

$(a_1，a_2，a_3，...， a_n)$ 一个数据元素可以是简单的一个数据，一个符号，也可以是复杂的若干个数据项组合。



【例一】26 个英文字母组成的字母表

可以表示为：$(A,B,C,...,Z)$



【例二】一副扑克牌的点数

可以表示为：$(2,3,...,10,J,Q,K,A)$



【例三】学生信息表

| 学号   | 姓名 | 性别 | 年龄 | 成绩 |
| ------ | ---- | ---- | ---- | ---- |
| 204101 | 王力 | 男   | 19   | 93   |
| 204102 | 李民 | 男   | 19   | 88   |
| 204103 | 马文 | 女   | 19   | 96   |
| 204104 | 李晓 | 男   | 20   | 99   |
| 204105 | 夏侬 | 女   | 20   | 76   |

可以表示为：$(stu_1，stu_2，stu_3，stu_4，stu_5)$



##	2.	顺序存储结构

###	1.	存储结构

数据结构在计算机中的表示，包括数据元素的表示和关系表示。

数据元素之间的关系在计算机中有两种不同的表示方法：

- 顺序存储结构——顺序表
- 链式存储结构——链表



###	2.	顺序存储结构

$(a_1，a_2，a_3，...，a_n)$

按逻辑依序依次存放在一组地址连续的存储单元组；

借助元素在存储器中的相对位置（物理关系）来表示数据元素之间的逻辑关系；

| 存储地址        | 内存状态 | 结点顺序 |
| --------------- | -------- | -------- |
| b               | $a_1$    | 1        |
| b + len         | $a_2$    | 2        |
| ......          | ......   | .        |
| b+( l - 1 )*len | $a_i$    | i        |
| ......          | ......   | .        |
| b+(n-1)*len     | a_n      | n        |
|                 | 空闲     |          |

C 语言实现：使用数组开辟一组连续的存储空间

```c
#define MAXSIZE 100				// 数组的最大下标
typedef struct{
    ElemType a[MAXSIZE+1];				// 线性表的存储空间，ElemType：表示数据元素类型，通用的表示方法
    int n;					// 线性表的长度；
}sqlist;						// 线性表类型
```



【例一】26 个英文字母组成的字母表

```c
#define MAXSIZE 100
typedef struct{
    char a[MAXSIZE+1];
    int n;  
}sqlist;
```

内存中的存储形式如下：

n = 26;

| A    | B    | C    | ...... | Z    |        |      |         |
| ---- | ---- | ---- | ------ | ---- | ------ | ---- | ------- |
| 1    | 2    | 3    | ...... | 26   | ...... |      | MAXSIZE |



【例二】学生信息表

| 学号   | 姓名 | 性别 | 年龄 | 成绩 |
| ------ | ---- | ---- | ---- | ---- |
| 204101 | 王力 | 男   | 19   | 93   |
| 204102 | 李民 | 男   | 19   | 88   |
| 204103 | 马文 | 女   | 19   | 96   |
| 204104 | 李晓 | 男   | 20   | 99   |
| 204105 | 夏侬 | 女   | 20   | 76   |

```c
#define MAXSIZE 100
struct student{
    int num;
    char name[20];
    char sex;
    int age;
    float score;
};
typedef struct{
    struct student a[MAXSIZE];
    int n;  
}sqlist;
```

内存中的存储形式如下：

| num   | 204101 | 204102 | 204103 | 204104 | 204105 |        |         |
| ----- | ------ | ------ | ------ | ------ | ------ | ------ | ------- |
| name  | 王力   | 李民   | 马文   | 李晓   | 夏侬   |        |         |
| sex   | 男     | 男     | 女     | 男     | 女     |        |         |
| age   | 19     | 19     | 19     | 20     | 20     |        |         |
| score | 93     | 88     | 96     | 99     | 76     |        |         |
|       | 1      | 2      | 3      | 4      | 5      | ...... | MAXSIZE |



**元素地址计算：**

$第i个元素地址：loc(a_i)=loc(a_1)+(i-1)*len$

【例三】学生信息表

| 学号   | 姓名 | 性别 | 年龄 | 成绩 |
| ------ | ---- | ---- | ---- | ---- |
| 204101 | 王力 | 男   | 19   | 93   |
| 204102 | 李民 | 男   | 19   | 88   |
| 204103 | 马文 | 女   | 19   | 96   |
| 204104 | 李晓 | 男   | 20   | 99   |
| 204105 | 夏侬 | 女   | 20   | 76   |

设：第一个元素的地址 $loc(1)=2000$，每一个元素所占的存储空间 $len=29$，则可以计算出：

$loc(3)=loc(1)+(3-1)*29=2058$



<font color=red>小结</font>：线性表的访问时随机的，可以访问任意位置。



####	1.	顺序表的算法 - 插入

**算法功能：**在线性表的第 i 处插入新元素 x。

【例一】设 $i=4，x=60$

| 23   | 41   | 12   | 54                       | 77   | 19   | 88   |      |      |
| ---- | ---- | ---- | ------------------------ | ---- | ---- | ---- | ---- | ---- |
|      |      |      | $\downarrow$（此处插入） |      |      |      |      |      |
| 23   | 41   | 12   | 60                       | 54   | 77   | 19   | 88   |      |

**算法思想：**

1. 入口判断：

   存储容量够吗？（n < MAXSIZE）

   插入的位置正确吗？（i>=1 && i<n+1）

   ```c
   if (L.n=MAXSIZE) error("溢出");
   	if(i<1 || i>L.n+1) error("插入位置错");
   ```

2. 元素 $a_i \sim a_n$ 位置后移：注意移动次序，<font color=red>从后往前移动</font>。

   ```c
   for(j=n; j>=i; j--){
       L.a[j+1]=L.a[j];
   }
   ```

3. 在线性表的第 i 处插入新元素 x

   ```c
   L.a[i]=x;
   ```

4. 表长加 1：n+1；

**算法设计：**

```C
#define MAXSIZE 100
typedef struct{
    ElemType a[MAXSIZE+1];	// 线性表的容量
    int n;
}sqlist;
void sq_ins(sqlist &L, int i, ElemType x){
    // 线性表 L 的第 i 处插入新元素 x
    int j;
    if(L.n=MAXSIZE) error("溢出");
    else if(i<1 || i>L.n+1) error("插入位置错误");
    else{
        for(j=L.n; j>=i; j--){
            L.a[j+1]=L.a[j];	// 元素后移
        }
    L.a[i]=x;	// 在第i处插入x
    L.n++;	// 表长加1
    }
}
```

**算法分析：**

插入算法的执行时间与元素的插入位置，即元素的移动次数有关。

| 插入位置 | 1    | 2    | ...  | i     | ...  | n-1  | n    | n+1  |
| -------- | ---- | ---- | ---- | ----- | ---- | ---- | ---- | ---- |
| 移动次数 | n    | n-1  | ...  | n-i+1 | ...  | 2    | 1    | 0    |

如果在任意处插入一个元素都是等概率的，则：$\sum_is(n)=\sum\limits_{i=1}^{n+1}\frac{n-i+1}{n+1}=\frac{n}{2}$

所以，在顺序表上做插入运算，平均要移动表长的一半结点，因此，算法的平均时间复杂度 $T(n)=O(n)$。

<font color=red>建议</font>：线性表无序时，最好在表尾（n+1）处插入。



####	2.	顺序表的算法 - 有序插入

算法功能：设线性表存于整型数组 $a[1..MAXSIZE]$ 的前 n 个分量中且递增有序，将 x 插入到线性表的适当位置。

【例一】插入 $x=49$

| a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 13   | 27   | 38   | 76   | 76   | 85   | 97   |

查找：

```c
i=1;
while(i<=L.n && i>L.a[i]) i++
```

插入：

```c
sq_ins(L,i,x);
```

逻辑：

```c
j=L.n;
while(j>=1 && x<L.a[j]){
    L.a[j+1]=L.a[j];		// 找到插入位置，并后移
    j--;
}
L.a[j+1]=x;
```

**算法设计：**

```c
#define MAXSIZE 100
typedef struct{
    ElemType a[MAXSIZE+1];	// 线性表的容量
    int n;
}sqlist;
void insert(sqlist &L, int x){
    if(L.n<MAXSIZE){	// 当顺序表不满时
        int j=L.n;
        while(j>=1 && x<L.a[j]){
            L.a[j+1]=L.a[j];
            j--;
        }
    L.a[j+1]=x;
    L.n++;
    }
}
```



####	3.	顺序表的算法 - 删除

算法功能：删除线性表中的第 i 个元素，并用 x 返回其值。

**算法思想：**

1. 入口函数

   线性表是空的吗？删除位置正确吗？

   ```c
   if(i<1 && i>L.n) error("删除位置错误");
   else if(L.n=0) error("表空");
   ```

2. 将第 i 个元素的值放入 x

   ```c
   x=L.a[i];
   ```

3. 元素 $a_{i+1} \sim a_n$ 前移，注意移动次序

   | 23   | 41   | 12   | 60              | 54   | 77   | 19   | 88   |      |
   | ---- | ---- | ---- | --------------- | ---- | ---- | ---- | ---- | ---- |
   |      |      |      | $\uparrow$ 删除 |      |      |      |      |      |
   | 23   | 41   | 12   | 54              | 77   | 19   | 88   |      |      |

   ```c
   for(int j=i+1; j<L.n; j++)
       L.a[j-1]=L.a[j];
   ```

4. 表长 -1：L.n--；

**算法设计：**

 ```c
 #define MAXSIZE 100
 typedef struct{
     ElemType a[MAXSIZE+1];	// 线性表的容量
     int n;
 }sqlist;
 void sq_del(sqlist &L, int i, ElemType x){
     // 删除线性表 L 中的第 i 个元素;
     if(i<1 || i>L.n) error("删除位置错误");
     else if(L.n==0) error("空表");
     else {
         for(int j=i+1; j<=L.n; j++){
             L.a[j-1]=L.a[j];
             L.n--;
         }
     }
 }
 ```

同删除算法一样，删除一个元素时，平均移动约表长的一半。$\sum De(n)=\sum\limits_{i=1}^{n}\frac{n-i}{n}=\frac{n-1}{2}$

算法的时间复杂度：$T(n)=O(n)$。



####	4.	顺序表的算法 - 删除从i开始的K个元素

算法功能：已知线性表存于 $v[1...MAXSIZE]$ 中的前 n 个分量中，写一个算法删除从第 i 个元素开始的 k 个元素。

设 $i=3，k=3$

| 23   | 41   | 12   | 54   | 77   | 19   | 88   | 92   |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      | i    |      |      | i+k  |      |      |      |

**算法思想：**

从第 i+k 个元素开始往前移动 k 个元素。

```c
j=i+k-n;
a[j-k]=a[j];
```

**算法设计：**

```c
#define MAXSIZE 100
typedef struct{
    ElemType a[MAXSIZE+1];	// 线性表的容量
    int n;
}sqlist;
void del(sqlist &L, int k, int i){
    // 本算法删除从第 i 个元素开始的 k 个元素；
    if(K>0 && 1<=i && i+k<=L.n){
        for(int j=i+k; j<=L.n; ++j){
            L.a[j-k]=L.a[j];
        }
    L.n -= k;
    }
}
```



###	3.	链式存储结构



