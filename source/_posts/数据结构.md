---
title: 数据结构
date: 2022-03-07 09:56:16
tags:
  - 考研
  - 专业课
  - 数据结构
  - 算法
categories:
  - 学术知识积累
mathjax: true
---

该文为学习笔记，仅作学习参考，如有错误，望指正！

<!--more-->

#	第一章.	绪论

数据结构在学什么？

​		<font color=red>如何用程序代码把现实世界的问题信息化</font>。

本章内容索引：

![](1.1.1.png)

##	1.	数据结构的基本概念

**相关概念：**

数据：数据是<font color=red>信息的载体</font>，是描述客观事物属性的数、字符以及所有<font color=red>能输入到计算机中并被计算机程序识别</font>和处理的符号的集合。数据是计算机程序加工的原料。

数据元素、数据项：**数据元素**是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素是由若干个数据项组成的，**数据项**是构成数据元素的不可分割的最小单位。

数据对象：是具有<font color=red>相同性质</font>的数据元素的集合，是数据的一个子集。

数据结构：是相互之间存在一种或多种特定<font color=red>关系</font>的数据元素的集合。

数据类型：是一个值的集合和定义在此集合上的一组操作的总称。

1. 原子类型：其值不可再分的数据类型。
2. 结构类型：其值可以再分解为若干成分（分量）的数据类型。

抽象数据类型（Abstract Data Type，ADT）：是抽象数据组织及与之相关的操作。用数学化的语言定义数据的逻辑结构、定义运算，与具体的实现无关。

**数据的逻辑结构：**

集合：各个元素同属一个集合，别无其他关系；

线性结构：元素之间是一对一的关系，除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继；

树形结构：数据元素之间是一对多的关系；

图形结构：数据元素之间是多对多的关系；

**数据的物理结构（存储结构）：**

顺序存储：把<font color=red>逻辑上相邻的元素存储在物理位置上也相邻的存储单元中</font>，元素之间的关系由存储单元的邻接关系来体现。

链式存储：<font color=red>逻辑上相邻的元素在物理位置上可以不相邻</font>，借助指示元素存储位置的指针来表示元素之间的逻辑关系。

索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）

散列存储：根据元素的关键字直接计算出该元素的存储地址，又称<font color=red>哈希（Hash）存储</font>。

<font color=red>【小结】</font>：

1. 若采用<font color=red>顺序存储</font>，则各个数据元素之间在物理上必须是<font color=red>连续的</font>，若采用<font color=red>非顺序存储</font>，则各个数据元素在物理上可以是<font color=red>离散的</font>。
2. 数据的<font color=red>存储结构</font>会<font color=red>影响存储空间分配的方便程度</font>。

**数据的运算：**

施加在数据上的运算包括运算的定义和实现。

<font color=red>运算的定义</font>是<font color=red>针对逻辑结构</font>的。

<font color=red>运算的实现</font>是<font color=red>针对存储结构</font>的。

<font color=red>根据逻辑结构来定义，根据存储结构来实现</font>。



##	2.	算法的基本概念

**程序=数据结构+算法；**

1. 数据结构：是要处理的信息；
2. 算法：是处理信息的步骤；

**算法的特性：**

1. 有穷性：有穷时间内能执行完成。<font color=red>算法是有穷的，程序可以是无穷的</font>。
2. 确定性：<font color=red>相同的输入</font>只会产生<font color=red>相同的输出</font>。
3. 可行性：可以用已有的基本操作实现算法。
4. 输入：一个算法<font color=red>有 0 个或多个输入</font>，即丢给算法处理的数据。
5. 输出：一个算法<font color=red>有 1 个或多个输出</font>，即算法处理的结果。

**"好"算法的特质：**

1. 正确性：算法应能够正确地解决求解问题。

2. 可读性：算法应具有良好的可读性，以帮助人们理解。

   <font color=red>注意</font>：算法可以用伪代码描述，甚至用文字描述，重要的是要"无歧义"地描述出解决问题的步骤。

3. 健壮性：输入非法数据时，算法能适当地作出反应或进行处理，而不会产生莫名其妙的输出结果。

4. 高效率与低存储量需求：

   1. 高效率：执行速度快，时间复杂度低；
   2. 低存储量：不费内存，空间复杂度低；



##	3.	算法的时间复杂度

【例一】

```c
void loveyou(int n){
    int i=1;
    while(i<=n){
        i++;
        printf("I Love You Than %d.\n", n);
    }
    printf("I Love You More than %d.\n", n);
}
int main(){
    loveyou(3000);
}
```

时间开销与问题规模 n 的关系：$T(n)=3n+3$

<font color=red>可以只考虑阶数高的部分</font>：即 $T(n)=O(n)$

1. 加法规则：$T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))$；
2. 乘法规则：$T(n)=T_1(n) \cdot T_2(n)=O(f(n)) \cdot O(g(n))=O(f(n) \cdot g(n))$；
3. <font color=red>$O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$</font>；

【例二】$T_3(n)=n^3+n^2log_2n$

解：$T_3(n)=O(n^3)+O(n^2log_2n)=O(n^3)$

<font color=red>【总结】</font>：

1. 顺序执行的代码只会影响常数项，可以忽略；
2. 只需挑循环中的一个基本操作分析它的执行次数与 n 的关系即可；
3. 如果有多层嵌套循环，只需关注最深层循环循环了几次；

最坏时间复杂度：最坏情况下算法的时间复杂度；

平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间；

最好时间复杂度：最好情况下算法的时间复杂度；（参考价值较小）



##	4.	算法的空间复杂度

【例一】

```c
void loveyou(int n){
    int i=1;
    while(i<=n){
        i++;
        printf("I Love You Than %d.\n", n);
    }
    printf("I Love You More than %d.\n", n);
}
```

无论问题规模怎么变，算法运行所需的内存空间都是固定的常量，算法空间复杂度为 $S(n)=O(1)$，注：S 表示"Space"

<font color=red>只需关注存储空间大小与问题规模相关的变量</font>。

